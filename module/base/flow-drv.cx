//-*-C-*-
/******************************************************************************/
enum E_flow_Z_run_state
{ E_flow_Z_run_state_S_ready
, E_flow_Z_run_state_S_waiting_for_report
, E_flow_Z_run_state_S_waiting_for_timer
, E_flow_Z_run_state_S_waiting_for_call_reply
, E_flow_Z_run_state_S_waiting_for_system_unblock_report
, E_flow_Z_run_state_S_stopping_by_task
};
struct E_flow_Q_task_Z
{ Pc exe_stack;
  Pc stack;
    #ifdef C_line_report
  Pc proc_name;
    #endif
  void ( *thread_unblock_proc )(P);
  P task_proc_arg;
  HANDLE thread_switch_in, thread_switch_out;
  I run_state_object;
  HANDLE thread;
  enum E_flow_Z_run_state run_state;
  unsigned U_R( type, system_unblock_report )   :1;
  unsigned U_R( type, async )                   :1;
};
struct E_flow_Q_task_async_Z_proc_args
{ P p;
  HANDLE thread_switch_in, thread_switch_out;
};
struct E_flow_Q_task_async_I_thread_proc_Z_args
{ void ( *task_proc )(P);
  struct E_flow_Q_task_async_Z_proc_args task_proc_arg;
};
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
struct E_flow_Q_report_Z
{ N uid;
  N reported_count;
};
struct E_flow_Q_timer_Z
{ N left;
  N period;
  N lost_count;
  N uid;
  I task_to;
};
//==============================================================================
_export
I
E_flow_Q_task_M( I *uid
, void ( *task_proc )(P)
, P task_proc_arg
, B task_system_unblock_report
, N stack_size
    #ifdef C_line_report
, Pc task_proc_name
    #endif
){  I task_id = E_mem_Q_tab_I_add( E_base_S->E_flow_Q_task_S );
    struct E_flow_Q_task_Z *task = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S, task_id );
        #ifdef C_line_report
    task->proc_name = task_proc_name;
        #endif
    task->run_state = E_flow_Z_run_state_S_ready;
    U_L( task->type, async );
    U_R( task->type, system_unblock_report ) = task_system_unblock_report;
    if( task_system_unblock_report )
    {   struct E_flow_Q_task_async_I_thread_proc_Z_args *M_( task_proc_args );
        if( !task_proc_args )
        {   N r = E_mem_Q_tab_I_remove( E_base_S->E_flow_Q_task_S, task_id );
            return r ? ~2 : ~0;
        }
        V( task->thread_switch_in = CreateEvent( 0, no, no, 0 ))
        {   N r = W( task_proc_args );
            if(r)
                return ~2;
            r = E_mem_Q_tab_I_remove( E_base_S->E_flow_Q_task_S, task_id );
            return r ? ~2 : ~0;
        }
        task_proc_args->task_proc_arg.thread_switch_in = task->thread_switch_in;
        V( task->thread_switch_out = CreateEvent( 0, no, no, 0 ))
        {   V( CloseHandle( task->thread_switch_in ));
                return ~2;
            N r = W( task_proc_args );
            if(r)
                return ~2;
            r = E_mem_Q_tab_I_remove( E_base_S->E_flow_Q_task_S, task_id );
            return r ? ~2 : ~0;
        }
        task_proc_args->task_proc_arg.thread_switch_out = task->thread_switch_out;
        task->task_proc_arg = task_proc_args->task_proc_arg.p = task_proc_arg;
        I task_id_ = E_base_S->E_flow_Q_task_S_current;
        E_base_S->E_flow_Q_task_S_current = task_id;
        V( task->thread = CreateThread( 0, E_base_S->E_mem_S_page_size, E_flow_Q_thread_system_unblock_report_I, task_proc_args, 0, 0 ))
        {   V( CloseHandle( task->thread_switch_out ));
                return ~2;
            V( CloseHandle( task->thread_switch_in ));
                return ~2;
            N r = W( task_proc_args );
            if(r)
                return ~2;
            r = E_mem_Q_tab_I_remove( E_base_S->E_flow_Q_task_S, task_id );
            return r ? ~2 : ~0;
        }
        SetThreadIdealProcessor( task->thread, 0 );
            #ifdef C_line_report
        int l_ = MultiByteToWideChar( CP_UTF8, MB_PRECOMPOSED, task_proc_name, ~0, 0, 0 );
        Pw s_ = Mt( sizeof(W), l_ );
        if( s_ )
        {   MultiByteToWideChar( CP_UTF8, MB_PRECOMPOSED, task_proc_name, ~0, s_, l_ );
            SetThreadDescription( task->thread, s_ );
            W( s_ );
        }
            #endif
        V_( SignalObjectAndWait( task->thread_switch_in, task->thread_switch_out, INFINITE, no ) == WAIT_OBJECT_0 );
        E_base_S->E_flow_Q_task_S_current = task_id_;
        return task_id;
    }
    stack_size++;
    stack_size *= E_base_S->E_mem_S_page_granulation;
    task->stack = VirtualAlloc( 0, stack_size, MEM_COMMIT | MEM_TOP_DOWN, PAGE_READWRITE );
    V( task->stack )
    {   N r = E_mem_Q_tab_I_remove( E_base_S->E_flow_Q_task_S, task_id );
        return r ? ~2 : ~0;
    }
    N32 prev;
    V( VirtualProtect( task->stack, E_base_S->E_mem_S_page_size, PAGE_NOACCESS, &prev ))
    {   V( VirtualFree( task->stack, 0, MEM_RELEASE ))
            return ~2;
        N r = E_mem_Q_tab_I_remove( E_base_S->E_flow_Q_task_S, task_id );
        return r ? ~2 : ~0;
    }
    *uid = task_id;
    task->exe_stack = 0;
    task->run_state_object = E_base_S->E_flow_Q_task_S_current;
    P exe_stack = task->stack + stack_size;
    P *p = ( P * )exe_stack - ( 4 + 1 );
    *p = (P)&E_flow_Q_task_I_stop;
    E_flow_Q_task_I_switch( task_id );
    if( !task->exe_stack ) // W bloku – nowe ‹zadanie›: nic nie zmieniać na stosie należącym do przełączanego.
    {   __asm__ volatile (
        "\n" "mov   %0,%%rsp"
        "\n" "jmp   *%1"
        :
        : "r" (p), "r" ( task_proc )
        : "rsp", "memory"
        );
        _unreachable;
    }
    return task_id;
}
// Nie wolno tworzyć “wątku”/‘instancji’ tego samego ‹zadania› w bloku startowym (innej ‘instancji’) tego samego ‹zadania›.
_export
I
E_flow_Q_task_M_thread( I *uid
, I subid
, void ( *task_proc )(P)
, P task_proc_arg
    #ifdef C_line_report
, Pc task_proc_name
    #endif
){  I uid_start = *uid;
    I id;
    if(( id = E_flow_Q_task_M( uid, task_proc, task_proc_arg, yes, 0
        #ifdef C_line_report
    , task_proc_name
        #endif
    )) < 0
    )
        return id;
    struct E_mem_Q_tab_Z **tab_subid;
    if( !~uid_start )
    {   *uid = E_mem_Q_tab_I_add( E_base_S->E_flow_Q_task_S_uid_subid );
        tab_subid = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S_uid_subid, *uid );
        *tab_subid = E_mem_Q_tab_M( sizeof(I), subid + 1 );
        if( !*tab_subid )
        {   N r = E_mem_Q_tab_I_remove( E_base_S->E_flow_Q_task_S_uid_subid, *uid );
            if(r)
                return r;
            r = E_flow_Q_task_W( &id );
            if(r)
                return r;
            return ~0;
        }
    }else
    {   tab_subid = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S_uid_subid, *uid );
        N r = E_mem_Q_tab_I_add_i( E_base_S->E_flow_Q_task_S_uid_subid, subid );
        if(r)
            return r;
    }
    *( I * )E_mem_Q_tab_R( *tab_subid, subid ) = id;
    return *uid;
}
// Procedura ‹zadań› wątkowanych.
_internal
N32
E_flow_Q_thread_system_unblock_report_I( P args_
){  struct E_flow_Q_task_async_I_thread_proc_Z_args *args = args_;
    args->task_proc( &args->task_proc_arg );
    V_( SetEvent( args->task_proc_arg.thread_switch_out ));
    return 0;
}
_export
N
E_flow_Q_task_W( I *uid
){  I id = *uid;
    *uid = ~0;
    struct E_flow_Q_task_Z *task = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S, id );
    task->run_state = E_flow_Z_run_state_S_stopping_by_task;
    task->run_state_object = E_base_S->E_flow_Q_task_S_current;
    if( U_R( task->type, system_unblock_report ))
    {   task->thread_unblock_proc( task->task_proc_arg );
        E_base_S->E_flow_Q_task_S_current = id;
        V_( WaitForSingleObject( task->thread_switch_out, INFINITE ) == WAIT_OBJECT_0 );
        E_base_S->E_flow_Q_task_S_current = task->run_state_object;
        O{  N32 exit_code;
            V_( GetExitCodeThread( task->thread, &exit_code ));
            if( exit_code != STILL_ACTIVE )
                break;
            SwitchToThread();
        }
        V( CloseHandle( task->thread ))
            return ~1;
        V( CloseHandle( task->thread_switch_out ))
            return ~1;
        V( CloseHandle( task->thread_switch_in ))
            return ~1;
        if( task->task_proc_arg )
        {   N r = W( task->task_proc_arg );
            if(r)
                return r;
        }
    }else
    {   E_flow_Q_task_I_switch(id); // Przełącz tylko po to, by ‹zadanie› zwalniane zwolniło zasoby; również stosowo, hierarchicznie z powrotem przełączając przy zwalnianiu ‹zadań› przez siebie uruchomionych.
        task = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S, id );
    }
    V( VirtualFree( task->stack, 0, MEM_RELEASE ))
        return ~2;
    return E_mem_Q_tab_I_remove( E_base_S->E_flow_Q_task_S, id ) ? ~2 : 0;
}
_export
N
E_flow_Q_task_W_thread( I *uid
, I subid
){  struct E_mem_Q_tab_Z **tab_subid = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S_uid_subid, *uid );
    I id = *( I * )E_mem_Q_tab_R( *tab_subid, subid );
    if( E_mem_Q_tab_R_n( *tab_subid ) != 1 )
    {   N r = E_mem_Q_tab_I_remove( *tab_subid, subid );
        if(r)
            return r;
    }else
    {   N r = E_mem_Q_tab_W( *tab_subid );
        if(r)
            return r;
        *uid = ~0;
    }
    return E_flow_Q_task_W( &id );
}
// ‹Zadanie› synchroniczne wykonuje to po wyjściu z procedury; ma adres powrotu na stosie.
_internal
void
E_flow_Q_task_I_stop( void
){  struct E_flow_Q_task_Z *task = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S, E_base_S->E_flow_Q_task_S_current );
    E_flow_Q_task_I_switch( task->run_state_object ); // Powrót do ‹zadania› zwalniającego bieżące.
    _unreachable;
}
//------------------------------------------------------------------------------
_export
I
E_flow_Q_task_async_M( I *uid
, void ( *task_proc )(P)
,  void ( *thread_unblock_proc )(P)
        #ifdef C_line_report
, Pc task_proc_name
        #endif
){  I task_id = E_mem_Q_tab_I_add( E_base_S->E_flow_Q_task_S );
    struct E_flow_Q_task_Z *task = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S, task_id );
        #ifdef C_line_report
    task->proc_name = task_proc_name;
        #endif
    task->run_state = E_flow_Z_run_state_S_ready;
    U_L( task->type, system_unblock_report );
    U_F( task->type, async );
    task->thread_unblock_proc = thread_unblock_proc;
    struct E_flow_Q_task_async_I_thread_proc_Z_args *M_( task_proc_args );
    if( !task_proc_args )
        return ~0;
    V( task->thread_switch_in = CreateEvent( 0, no, no, 0 ))
    {   N r = E_mem_Q_tab_I_remove( E_base_S->E_flow_Q_task_S, task_id );
        if(r)
            return r;
        r = W( task_proc_args );
        return r ? r : ~0;
    }
    task_proc_args->task_proc_arg.thread_switch_in = task->thread_switch_in;
    V( task->thread_switch_out = CreateEvent( 0, no, no, 0 ))
    {   V( CloseHandle( task->thread_switch_in ));
            return ~2;
        N r = E_mem_Q_tab_I_remove( E_base_S->E_flow_Q_task_S, task_id );
        if(r)
            return r;
        r = W( task_proc_args );
        return r ? r : ~0;
    }
    task_proc_args->task_proc_arg.thread_switch_out = task->thread_switch_out;
    V( task->thread = CreateThread( 0, E_base_S->E_mem_S_page_size, E_flow_Q_thread_system_unblock_report_I, task_proc_args, 0, 0 ))
    {   V( CloseHandle( task->thread_switch_out ));
            return ~2;
        V( CloseHandle( task->thread_switch_in ));
            return ~2;
        N r = E_mem_Q_tab_I_remove( E_base_S->E_flow_Q_task_S, task_id );
        if(r)
            return r;
        r = W( task_proc_args );
        return r ? r : ~0;
    }
    if( E_base_S->cpu_taken )
    {   SYSTEM_INFO si;
        GetSystemInfo( &si );
        N cpu_n = si.dwNumberOfProcessors;
        if( --cpu_n )
        {   B fail = no;
            if( cpu_n != E_base_S->cpu_taken_length )
                if( ~E_mem_Q_mask_I_resize( &E_base_S->cpu_taken, E_base_S->cpu_taken_length, cpu_n ))
                    E_base_S->cpu_taken_length = cpu_n;
                else
                    fail = yes;
            if( !fail )
            {   N cpu_i = E_mem_Q_mask_R_first_clear( E_base_S->cpu_taken, E_base_S->cpu_taken_length );
                if( ~cpu_i )
                    SetThreadIdealProcessor( task->thread, cpu_i + 1 );
            }
        }
    }
        #ifdef C_line_report
    int l_ = MultiByteToWideChar( CP_UTF8, MB_PRECOMPOSED, task_proc_name, ~0, 0, 0 );
    Pw s_ = Mt( sizeof(W), l_ );
    if( s_ )
    {   MultiByteToWideChar( CP_UTF8, MB_PRECOMPOSED, task_proc_name, ~0, s_, l_ );
        SetThreadDescription( task->thread, s_ );
        W( s_ );
    }
        #endif
    *uid = task_id;
    return task_id;
}
// Procedura ‹zadań› asynchronicznych.
_internal
P
E_flow_Q_thread_async_I( P args_
){  struct E_flow_Q_task_async_I_thread_proc_Z_args *args = args_;
    args->task_proc( &args->task_proc_arg );
    V_( SetEvent( args->task_proc_arg.thread_switch_out ));
    return 0;
}
_export
N
E_flow_Q_task_async_W( I *uid
){  I id = *uid;
    *uid = ~0;
    struct E_flow_Q_task_Z *task = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S, id );
    task->run_state = E_flow_Z_run_state_S_stopping_by_task;
    task->run_state_object = E_base_S->E_flow_Q_task_S_current;
    PROCESSOR_NUMBER pn;
    N r = GetThreadIdealProcessorEx( task->thread, &pn );
    if(r)
        if( pn.Number < E_base_S->cpu_taken_length + 1 )
            E_mem_Q_mask_P_clear( E_base_S->cpu_taken, pn.Number - 1 );
    task->thread_unblock_proc( task->task_proc_arg );
    E_base_S->E_flow_Q_task_S_current = id;
    V_( WaitForSingleObject( task->thread_switch_out, INFINITE ) == WAIT_OBJECT_0 );
    E_base_S->E_flow_Q_task_S_current = task->run_state_object;
    O{  N32 exit_code;
        V_( GetExitCodeThread( task->thread, &exit_code ));
        if( exit_code != STILL_ACTIVE )
            break;
        SwitchToThread();
    }
    V( CloseHandle( task->thread ))
        return ~1;
    V( CloseHandle( task->thread_switch_out ))
        return ~1;
    V( CloseHandle( task->thread_switch_in ))
        return ~1;
    return E_mem_Q_tab_I_remove( E_base_S->E_flow_Q_task_S, id ) ? ~2 : 0;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
_export
I
E_flow_Q_report_M( N uid
){  struct E_flow_Q_report_Z *report;
    for_each( report_id, E_base_S->E_flow_Q_report_S, E_mem_Q_tab )
    {   report = E_mem_Q_tab_R( E_base_S->E_flow_Q_report_S, report_id );
        if( report->uid == uid )
            break;
    }
    if( !~report_id )
    {   report_id = E_mem_Q_tab_I_add( E_base_S->E_flow_Q_report_S );
        if( report_id < 0 )
            return report_id;
        report = E_mem_Q_tab_R( E_base_S->E_flow_Q_report_S, report_id );
        report->uid = uid;
        report->reported_count = 0;
    }
    return report_id;
}
_export
N
E_flow_Q_report_W( I id
){  return E_mem_Q_tab_I_remove( E_base_S->E_flow_Q_report_S, id );
}
//------------------------------------------------------------------------------
_export
void
E_flow_Q_report_I_signal( I id
){  struct E_flow_Q_report_Z *report = E_mem_Q_tab_R( E_base_S->E_flow_Q_report_S, id );
    if( ~report->reported_count )
        report->reported_count++;
    for_each( task_id, E_base_S->E_flow_Q_task_S, E_mem_Q_tab )
    {   struct E_flow_Q_task_Z *task = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S, task_id );
        if( U_R( task->type, async ))
            continue;
        if( task->run_state == E_flow_Z_run_state_S_waiting_for_report
        && task->run_state_object == id
        )
        {   task->run_state = E_flow_Z_run_state_S_ready;
            break;
        }
    }
}
_export
B
E_flow_Q_report_I_wait( I id
, N *lost_count
){  B r;
    struct E_flow_Q_report_Z *report = E_mem_Q_tab_R( E_base_S->E_flow_Q_report_S, id );
    if( report->reported_count )
    {   //for_each( task_id, E_base_S->E_flow_Q_task_S, E_mem_Q_tab )
        //{   struct E_flow_Q_task_Z *task = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S, task_id );
            //if( U_R( task->type, async ))
                //continue;
            //if( task->run_state == E_flow_Z_run_state_S_emiting_report
            //&& task->run_state_object == id
            //)
                //task->run_state = E_flow_Z_run_state_S_ready;
        //}
        r = no; // Nie wywołuje “schedule”, ponieważ w przełączanym tylko w oznaczonych punktach przepływie wykonania — bieżące ‹zadanie› mogło umożliwić zaistnienie ‹raportu›, na który czeka, tylko wtedy, jeśli przełącza do innych ‹zadań› ·w innych punktach niż to oczekiwanie na ‹raport›·, więc po co czekać, skoro nie zaburza cyklu przełączania ‹zadań›, a tylko w implementacji własnego ‹zadania› zmienia na złożoną (przesuniętą) sekwencję przełączania.
    }else
    {   struct E_flow_Q_task_Z *task = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S, E_base_S->E_flow_Q_task_S_current );
        task->run_state = E_flow_Z_run_state_S_waiting_for_report;
        task->run_state_object = id;
        r = E_flow_Q_task_I_schedule();
        report = E_mem_Q_tab_R( E_base_S->E_flow_Q_report_S, id );
    }
    if( lost_count )
        *lost_count = report->reported_count - 1;
    report->reported_count = 0;
    return r;
}
_export
void
E_flow_Q_report_I_clear( I id
){  struct E_flow_Q_report_Z *report = E_mem_Q_tab_R( E_base_S->E_flow_Q_report_S, id );
    report->reported_count = 0;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
_export
I
E_flow_Q_timer_M( N period
){  N t = GetTickCount64();
    I timer_id = E_mem_Q_tab_I_add( E_base_S->E_flow_Q_timer_S );
    if( timer_id < 0 )
        return timer_id;
    struct E_flow_Q_timer_Z *timer = E_mem_Q_tab_R( E_base_S->E_flow_Q_timer_S, timer_id );
    timer->period = period;
    timer->lost_count = 0;
    timer->uid = ~0;
    timer->task_to = E_base_S->E_flow_Q_task_S_current;
    if( E_mem_Q_tab_R_n( E_base_S->E_flow_Q_timer_S ) != 1 )
    {   for_each_out( timer_id, timer_id_, E_base_S->E_flow_Q_timer_S, E_mem_Q_tab )
        {   struct E_flow_Q_timer_Z *timer_ = E_mem_Q_tab_R( E_base_S->E_flow_Q_timer_S, timer_id_ );
            if( timer_->period // Jest co najmniej jeden ‹cykler›
            || timer_->left // lub co najmniej jeden wzbudzony ‹impulsator›.
            )
            {   t += timer->period;
                if( t < E_base_S->E_flow_Q_timer_S_next_real_time )
                    E_base_S->E_flow_Q_timer_S_next_real_time = t;
                timer->left = t - E_base_S->E_flow_Q_timer_S_last_real_time;
                return timer_id;
            }
        }
    }
    E_base_S->E_flow_Q_timer_S_last_real_time = t;
    E_base_S->E_flow_Q_timer_S_next_real_time = t + timer->period;
    timer->left = timer->period;
    return timer_id;
}
_export
N
E_flow_Q_timer_W( I id
){  N r = E_mem_Q_tab_I_remove( E_base_S->E_flow_Q_timer_S, id );
    if(r)
        return r;
    for_each( timer_id, E_base_S->E_flow_Q_timer_S, E_mem_Q_tab )
    {   struct E_flow_Q_timer_Z *timer = E_mem_Q_tab_R( E_base_S->E_flow_Q_timer_S, timer_id );
        if( timer->period
        || timer->left
        )
            return 0;
    }
    E_base_S->E_flow_Q_timer_S_next_real_time = ~0;
    return 0;
}
//------------------------------------------------------------------------------
_export
B
E_flow_Q_timer_I_wait( I id
, N *lost_count
){  struct E_flow_Q_task_Z *task = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S, E_base_S->E_flow_Q_task_S_current );
    task->run_state = E_flow_Z_run_state_S_waiting_for_timer;
    task->run_state_object = id;
    B r = E_flow_Q_task_I_schedule();
    struct E_flow_Q_timer_Z *timer = E_mem_Q_tab_R( E_base_S->E_flow_Q_timer_S, id );
    if( lost_count )
        *lost_count = timer->lost_count;
    timer->lost_count = 0;
    return r;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
_export
I
E_flow_Q_impulser_M( N uid
){  struct E_flow_Q_timer_Z *timer;
    for_each( timer_id, E_base_S->E_flow_Q_timer_S, E_mem_Q_tab )
    {   timer = E_mem_Q_tab_R( E_base_S->E_flow_Q_timer_S, timer_id );
        if( timer->uid == uid )
            break;
    }
    if( !~timer_id )
    {   timer_id = E_mem_Q_tab_I_add( E_base_S->E_flow_Q_timer_S );
        if( timer_id < 0 )
            return timer_id;
        timer = E_mem_Q_tab_R( E_base_S->E_flow_Q_timer_S, timer_id );
        timer->left = 0;
        timer->period = 0;
        timer->uid = uid;
    }
    timer->task_to = E_base_S->E_flow_Q_task_S_current;
    return timer_id;
}
_export
I
E_flow_Q_impulser_M_srv( N uid
){  struct E_flow_Q_timer_Z *timer;
    for_each( timer_id, E_base_S->E_flow_Q_timer_S, E_mem_Q_tab )
    {   timer = E_mem_Q_tab_R( E_base_S->E_flow_Q_timer_S, timer_id );
        if( timer->uid == uid )
            break;
    }
    if( !~timer_id )
    {   timer_id = E_mem_Q_tab_I_add( E_base_S->E_flow_Q_timer_S );
        if( timer_id < 0 )
            return timer_id;
        timer = E_mem_Q_tab_R( E_base_S->E_flow_Q_timer_S, timer_id );
        timer->left = 0;
        timer->period = 0;
        timer->uid = uid;
    }
    return timer_id;
}
//------------------------------------------------------------------------------
_export
void
E_flow_Q_impulser_I_activate( I id
, N time
){  if( !time )
        time = 1;
    N t = GetTickCount64();
    struct E_flow_Q_timer_Z *timer = E_mem_Q_tab_R( E_base_S->E_flow_Q_timer_S, id );
    timer->left = time;
    if( E_mem_Q_tab_R_n( E_base_S->E_flow_Q_timer_S ) != 1 )
    {   for_each_out( id, timer_id_, E_base_S->E_flow_Q_timer_S, E_mem_Q_tab )
        {   struct E_flow_Q_timer_Z *timer_ = E_mem_Q_tab_R( E_base_S->E_flow_Q_timer_S, timer_id_ );
            if( timer_->period
            || timer_->left
            )
            {   t += timer->left;
                if( t < E_base_S->E_flow_Q_timer_S_next_real_time )
                    E_base_S->E_flow_Q_timer_S_next_real_time = t;
                timer->left = t - E_base_S->E_flow_Q_timer_S_last_real_time;
                return;
            }
        }
    }
    E_base_S->E_flow_Q_timer_S_last_real_time = t;
    E_base_S->E_flow_Q_timer_S_next_real_time = t + timer->left;
}
_export
void
E_flow_Q_impulser_I_deactivate( I id
){  struct E_flow_Q_timer_Z *timer = E_mem_Q_tab_R( E_base_S->E_flow_Q_timer_S, id );
    if( !timer->left )
        return;
    timer->left = 0;
    for_each_out( id, timer_id_, E_base_S->E_flow_Q_timer_S, E_mem_Q_tab )
    {   struct E_flow_Q_timer_Z *timer_ = E_mem_Q_tab_R( E_base_S->E_flow_Q_timer_S, timer_id_ );
        if( timer_->period
        || timer_->left
        )
            return;
    }
    E_base_S->E_flow_Q_timer_S_next_real_time = ~0;
}
//------------------------------------------------------------------------------
//NDFN Dodać “lost_count”?
_export
B
E_flow_Q_impulser_I_wait( I id
){  struct E_flow_Q_task_Z *task = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S, E_base_S->E_flow_Q_task_S_current );
    task->run_state = E_flow_Z_run_state_S_waiting_for_timer;
    task->run_state_object = id;
    return E_flow_Q_task_I_schedule();
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
_export
void
E_flow_Q_thread_system_unblock_report_I_before_async(
  HANDLE thread_switch_in
, HANDLE thread_switch_out
){  V_( SignalObjectAndWait( thread_switch_out, thread_switch_in, INFINITE, no ) == WAIT_OBJECT_0 );
}
_export
B
E_flow_Q_thread_system_unblock_report_I_after_async(
  HANDLE thread_switch_in
, HANDLE thread_switch_out
){  V_( SetEvent( thread_switch_out ));
    V_( SetEvent( E_base_S->E_flow_S_resume ));
    V_( WaitForSingleObject( thread_switch_in, INFINITE ) == WAIT_OBJECT_0 );
    struct E_flow_Q_task_Z *task = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S, E_base_S->E_flow_Q_task_S_current );
    return task->run_state == E_flow_Z_run_state_S_stopping_by_task;
}
_export
void
E_flow_Q_thread_system_unblock_report_I_unblock( I task_uid
, I task_subid
){  struct E_mem_Q_tab_Z **tab_subid = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S_uid_subid, task_uid );
    struct E_flow_Q_task_Z *task = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S, *( I * )E_mem_Q_tab_R( *tab_subid, task_subid ));
    task->thread_unblock_proc( task->task_proc_arg );
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
_export
B
E_flow_Q_thread_async_I_before_sync(
  HANDLE thread_switch_in
, HANDLE thread_switch_out
){  V_( SetEvent( thread_switch_out ));
    V_( SetEvent( E_base_S->E_flow_S_resume ));
    V_( WaitForSingleObject( thread_switch_in, INFINITE ) == WAIT_OBJECT_0 );
    struct E_flow_Q_task_Z *task = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S, E_base_S->E_flow_Q_task_S_current );
    return task->run_state == E_flow_Z_run_state_S_stopping_by_task;
}
_export
void
E_flow_Q_thread_async_I_after_sync(
  HANDLE thread_switch_in
, HANDLE thread_switch_out
){  V_( SignalObjectAndWait( thread_switch_out, thread_switch_in, INFINITE, no ) == WAIT_OBJECT_0 );
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Każde ‹zadanie› synchroniczne po wywołaniu “E_flow_Q_task_I_schedule” i po przełączeniu w tej procedurze do innego ‹zadania› (“E_flow_Q_task_I_switch”) czeka przed instrukcją powrotu z tej procedury, by kontynuować w miejscu wywołania i ewentualnie zakończyć własne ‹zadanie› po powrocie.
_export
__attribute__ (( __noinline__, __returns_twice__, __hot__ ))
B
E_flow_Q_task_I_schedule( void
){  _forced_statement;
    I schedule_task_id = E_base_S->E_flow_Q_task_S_current;
Loop:
    O{  if( U_E( E_base_S->E_flow_S_signal, exit ))
        {   struct E_flow_Q_task_Z *task = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S, 0 );
            task->run_state = E_flow_Z_run_state_S_stopping_by_task;
            if( E_base_S->E_flow_Q_task_S_current != schedule_task_id )
                E_base_S->E_flow_Q_task_S_current = schedule_task_id;
            if( E_base_S->E_flow_Q_task_S_current )
            {   E_flow_Q_task_I_switch(0);
                task = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S, E_base_S->E_flow_Q_task_S_current );
                return task->run_state == E_flow_Z_run_state_S_stopping_by_task;
            }
            return yes;
        }
        N next_real_time = ~0ULL;
        N t = GetTickCount64();
        if( t >= E_base_S->E_flow_Q_timer_S_next_real_time ) // Czy trzeba uaktualnić kolejne czasy ‹cyklerów›.
        {   N elapsed_time;
            elapsed_time = t - E_base_S->E_flow_Q_timer_S_last_real_time;
            //NDFN Uzupełnić o jakieś przewidywanie ‘overhead’ na podstawie poprzedniego, by wyeliminować możliwość powtarzania pętli w pesymistycznym przypadku dla każdego ‹cyklera›? Ale obliczać ten czas tylko wtedy, jeżeli ten fragment nie będzie mógł być wywłaszczony z wykonywania w czasie rzeczywistym (wszystkie przerwania wyłączone).
            O{  B some_timer_is_active = no, some_timer_has_deactivated = no;
                B some_task_got_ready = no;
                N suspend_time = ~0ULL;
                for_each( timer_id, E_base_S->E_flow_Q_timer_S, E_mem_Q_tab )
                {   struct E_flow_Q_timer_Z *timer = E_mem_Q_tab_R( E_base_S->E_flow_Q_timer_S, timer_id );
                    if( timer->period ) // ‹cykler›.
                    {   if( elapsed_time >= timer->left ) // ‹cykler› wykonał obieg— ‹zadanie› do wznowienia.
                        {   N overlate_time;
                            overlate_time = elapsed_time - timer->left;
                            if( overlate_time >= timer->period ) // ‹cykler› wykonał więcej niż jeden obieg.
                            {   do
                                {   timer->lost_count++;
                                    overlate_time -= timer->period;
                                }while( overlate_time >= timer->period );
                                GV_(NA); Gd( timer->lost_count ); Gd( timer->period ); Gd( overlate_time ); // lost time.
                            }
                            timer->left = timer->period - overlate_time;
                            struct E_flow_Q_task_Z *task = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S, timer->task_to );
                            if( task->run_state == E_flow_Z_run_state_S_waiting_for_timer
                            && task->run_state_object == timer_id
                            )
                            {   task->run_state = E_flow_Z_run_state_S_ready;
                                some_task_got_ready = yes;
                            }else
                                timer->lost_count++;
                        }else
                            timer->left -= elapsed_time;
                        if( timer->left < suspend_time )
                        {   suspend_time = timer->left;
                            some_timer_is_active = yes;
                        }
                    }else if( timer->left ) // Aktywowany ‹impulsator›.
                    {   if( elapsed_time >= timer->left )
                        {   timer->left = 0;
                            struct E_flow_Q_task_Z *task = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S, timer->task_to );
                            if( task->run_state == E_flow_Z_run_state_S_waiting_for_timer
                            && task->run_state_object == timer_id
                            )
                            {   task->run_state = E_flow_Z_run_state_S_ready;
                                some_task_got_ready = yes;
                            } // Narazie – jeśli nie może wznowić ‹zadania›, to gubi impuls.
                            some_timer_has_deactivated = yes;
                        }else
                        {   timer->left -= elapsed_time;
                            if( timer->left < suspend_time )
                            {   suspend_time = timer->left;
                                some_timer_is_active = yes;
                            }
                        }
                    }
                }
                if( some_timer_has_deactivated
                && !some_timer_is_active
                ){  E_base_S->E_flow_Q_timer_S_next_real_time = ~0ULL;
                    break;
                }
                N t_2 = GetTickCount64();
                elapsed_time = t_2 - t;
                if( elapsed_time < suspend_time // Czy przeliczanie czasów ‹cyklerów› trwało krócej niż obliczony czas oczekiwania do pierwszego budzącego ‹zadanie›?
                || !some_task_got_ready
                ){  E_base_S->E_flow_Q_timer_S_last_real_time = t;
                    E_base_S->E_flow_Q_timer_S_next_real_time = t + suspend_time; //NDFN Rozważyć przepełnienie licznika czasu rzeczywistego.
                    break;
                }
                t = t_2;
                GV_(NA); Gd( suspend_time ); Gd( elapsed_time ); // Timer schedule loop overhead.
            }
        }
        for_each_out( E_base_S->E_flow_Q_task_S_current, task_id, E_base_S->E_flow_Q_task_S, E_mem_Q_tab )
        {   B task_skip = no;
            for_each( task_id_, E_base_S->E_flow_Q_task_S, E_mem_Q_tab )
            {   struct E_flow_Q_task_Z *task = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S, task_id_ );
                if( task->run_state == E_flow_Z_run_state_S_stopping_by_task
                && task->run_state_object == task_id
                ) // Nie przełączaj do ‹zadania›, które jest w trakcie wyrzucania innego.
                {   task_skip = yes;
                    break;
                }
            }
            if( !task_skip )
            {   struct E_flow_Q_task_Z *task = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S, task_id );
                if( U_R( task->type, system_unblock_report ))
                {   if( task->run_state == E_flow_Z_run_state_S_ready
                    && WaitForSingleObject( task->thread_switch_out, 0 ) == WAIT_OBJECT_0
                    )
                    {   E_base_S->E_flow_Q_task_S_current = task_id;
                        V_( SignalObjectAndWait( task->thread_switch_in, task->thread_switch_out, INFINITE, no ) == WAIT_OBJECT_0 );
                        goto Loop; // Wywołuje “E_flow_Q_task_I_schedule” w sposób wewnętrzny, gdy nie można użyć funkcjonalności “E_flow_Q_task_I_switch”, ale przy pierwszej konieczności przełączenia standardowego będzie przełączał w trybie ·pominięcia nie obługiwanych systemowych danych zatrzymywania przepływu wykonania z tablicy ‹zadań›· (pominięcia ‹zadań›) przekazanych kolejnych typu “wątkowanych” ‹systemowych raportów odblokowujących› z “cyklicznej kolejki” — na rzecz zwykłego ‹zadania› (“schedule_task_id”), które wywołało “schedule”.
                    }
                }else if( U_R( task->type, async ))
                {   if( task->run_state == E_flow_Z_run_state_S_ready
                    && WaitForSingleObject( task->thread_switch_out, 0 ) == WAIT_OBJECT_0
                    )
                    {   E_base_S->E_flow_Q_task_S_current = task_id;
                        V_( SignalObjectAndWait( task->thread_switch_in, task->thread_switch_out, INFINITE, no ) == WAIT_OBJECT_0 );
                        goto Loop;
                    }
                }else if( task->run_state == E_flow_Z_run_state_S_ready )
                {   if( E_base_S->E_flow_Q_task_S_current != schedule_task_id )
                        E_base_S->E_flow_Q_task_S_current = schedule_task_id;
                    if( task_id != E_base_S->E_flow_Q_task_S_current )
                    {   E_flow_Q_task_I_switch( task_id );
                        task = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S, E_base_S->E_flow_Q_task_S_current );
                    }
                    return task->run_state == E_flow_Z_run_state_S_stopping_by_task;
                }
            }
        }
        B task_skip = no;
        for_each( task_id_, E_base_S->E_flow_Q_task_S, E_mem_Q_tab )
        {   struct E_flow_Q_task_Z *task = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S, task_id_ );
            if( task->run_state == E_flow_Z_run_state_S_stopping_by_task
            && task->run_state_object == E_base_S->E_flow_Q_task_S_current
            )
            {   task_skip = yes;
                break;
            }
        }
        if( !task_skip )
        {   struct E_flow_Q_task_Z *task = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S, E_base_S->E_flow_Q_task_S_current );
            if( U_R( task->type, system_unblock_report ))
            {   if( task->run_state == E_flow_Z_run_state_S_ready
                && WaitForSingleObject( task->thread_switch_out, 0 ) == WAIT_OBJECT_0
                )
                {   V_( SignalObjectAndWait( task->thread_switch_in, task->thread_switch_out, INFINITE, no ) == WAIT_OBJECT_0 );
                    continue;
                }
            }else if( U_R( task->type, async ))
            {   if( task->run_state == E_flow_Z_run_state_S_ready
                && WaitForSingleObject( task->thread_switch_out, 0 ) == WAIT_OBJECT_0
                )
                {   V_( SignalObjectAndWait( task->thread_switch_in, task->thread_switch_out, INFINITE, no ) == WAIT_OBJECT_0 );
                    continue;
                }
            }else if( task->run_state == E_flow_Z_run_state_S_ready )
            {   if( E_base_S->E_flow_Q_task_S_current != schedule_task_id )
                    E_base_S->E_flow_Q_task_S_current = schedule_task_id;
                return task->run_state == E_flow_Z_run_state_S_stopping_by_task;
            }
        }
        if( U_R( E_base_S->E_flow_S_signal, exit ))
            continue;
        if( next_real_time > E_base_S->E_flow_Q_timer_S_next_real_time )
            next_real_time = E_base_S->E_flow_Q_timer_S_next_real_time;
        B U_has_suspend_time = ~next_real_time;
        if( U_has_suspend_time )
            t = GetTickCount64();
        if( !U_has_suspend_time
        || t < next_real_time
        )
        {   N ret = MsgWaitForMultipleObjects( 1, &E_base_S->E_flow_S_resume, no, U_has_suspend_time ? next_real_time - t : INFINITE, QS_ALLEVENTS );
            switch(ret)
            { case WAIT_OBJECT_0:
                    break;
              case WAIT_OBJECT_0 + 1:
                {   X_A( window, loop );
                    X_F( window, loop );
                    ResetEvent( E_base_S->E_flow_S_resume );
                    break;
                }
              case WAIT_TIMEOUT:
                    break;
              default:
                {   GV_(NA); Gh(ret); _V();
                }
            }
        }
    }
}
// Przełączenie do ‹zadania› przez przełączenie wskaźnika “stosu” wykonania.
_internal
__attribute__ (( __noinline__, __returns_twice__, __hot__ ))
void
E_flow_Q_task_I_switch( I task_to_id
){  struct E_flow_Q_task_Z *task_from = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S, E_base_S->E_flow_Q_task_S_current );
    struct E_flow_Q_task_Z *task_to = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S, task_to_id );
    E_base_S->E_flow_Q_task_S_current = task_to_id;
    __asm__ volatile (
    "\n" "mov       %%rsp,%0"
    "\n" "test      %1,%1"
    "\n" "cmovnz    %1,%%rsp"
    : "=m" ( task_from->exe_stack )
    : "r" ( task_to->exe_stack )
    : "cc", "rsp", "memory"
    , "st", "st(1)", "st(2)", "st(3)", "st(4)", "st(5)", "st(6)", "st(7)"
    , "mm0", "mm1", "mm2", "mm3", "mm4", "mm5", "mm6", "mm7"
    , "xmm0", "xmm1", "xmm2", "xmm3", "xmm4", "xmm5", "xmm6", "xmm7"
    , "rbx", "rcx", "rsi", "rdi"
    , "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"
        #ifdef __SSE3__
    , "xmm8", "xmm9", "xmm10", "xmm11", "xmm12", "xmm13", "xmm14", "xmm15"
            #ifdef __AVX__
    , "ymm0", "ymm1", "ymm2", "ymm3", "ymm4", "ymm5", "ymm6", "ymm7", "ymm8", "ymm9", "ymm10", "ymm11", "ymm12", "ymm13", "ymm14", "ymm15"
            #endif
        #endif
    );
}
/******************************************************************************/
