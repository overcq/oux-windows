//-*-C-*-
/*******************************************************************************
*   ___   publicplace
*  ¦OUX¦  C+
*  ¦/C+¦  component
*   ---   base
*         wyrzucanie ‹modu³u› przy zakoñczeniu programu
* ©overcq                on "Gentoo Linux 13.0” “x86_64”             2016-2-28 M
*******************************************************************************/
//DFN globalnie: usuniêcie ‹modu³u› ([…]“_W”) mo¿e byæ wykonane w programie tylko raz.
//==============================================================================
//TODO Procedura do u³o¿enia.
void
E_base_W( void
){  D_W( mem, file_save );
    D_W( flow, call_srv ); // Przedostatnie ‹zadanie›.
    // Dopóki wypisywanie “G”[…] jest do tego samego “strumienia” jak “G”[…]“_”, to jeœli ‹raporty linii› s¹ w³¹czone, to znak nowej linii jest dorzucany synchronicznie, na koñcu tej procedury usuwania ‹modu³u›.
        //#ifdef C_line_report
    //E_io_Q_stream_out_P_c( 0, '\n' );
        //#endif
    struct E_flow_Q_task_Z *task = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S, 0 );
    task->run_state = E_flow_Z_run_state_S_ready;
    I_B(); // Mo¿e prze³¹czyæ do ostatniego ‹zadania›.
//    D_W( io, stream_write );
    for_each( call_id, E_base_S->E_flow_Q_process_call_cli_S, E_mem_Q_tab )
    {   struct E_flow_Q_process_call_cli_Z *call = E_mem_Q_tab_R( E_base_S->E_flow_Q_process_call_cli_S, call_id );
//        E_mem_Q_shared_W( call->shm_id );
    }
        #ifdef C_line_report
    E_flow_Z_line_report_I_write_Z_c( '\n' );
        #endif
}
/******************************************************************************/
