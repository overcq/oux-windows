//-*-C-*-
/******************************************************************************/
_export
struct E_base_Z
{ N E_flow_Q_timer_S_last_real_time;
  N E_flow_Q_timer_S_next_real_time;
  Pw E_flow_S_system_name;
  Pw E_flow_S_exe_name;
  HINSTANCE E_flow_S_h_instance;
  Pw E_flow_S_cmd_line;
  Pw E_flow_S_cwd;
  Pc cpu_taken;
  N cpu_taken_length;
  HANDLE E_mem_Q_blk_S_threads_sync_mutex;
  N E_mem_S_page_size;
  N E_mem_S_page_granulation;
  struct E_mem_Q_blk_Z_allocated *E_mem_Q_blk_S_allocated;
  N E_mem_Q_blk_S_mapped_id, E_mem_Q_blk_S_decommited_id, E_mem_Q_blk_S_free_id, E_mem_Q_blk_S_allocated_id;
  N *E_mem_Q_blk_Q_table_M_from_free_or_map_S_allocated_id[3];
  N E_mem_Q_blk_Q_table_M_from_free_or_map_S_table_id[3];
  N E_mem_Q_blk_Q_table_M_from_free_or_map_S_allocated_id_n;
  struct E_mem_Q_tab_Z *E_flow_Q_task_S; // Ta tablica nie może mieć tworzonego “E_mem_Q_tab_Q_iter”.
  struct E_mem_Q_tab_Z *E_flow_Q_task_S_uid_subid;
  struct E_mem_Q_tab_Z *E_flow_Q_report_S;
  struct E_mem_Q_tab_Z *E_flow_Q_timer_S;
  struct E_mem_Q_tab_Z *E_mem_Q_file_S;
  Pc E_mem_Q_file_S_buffer;
  N E_mem_Q_file_S_buffer_l;
  struct E_mem_Q_tab_Z *E_io_Q_stream_out_S;
  N32 E_flow_S_exe_pid;
  N32 E_flow_S_stderr_cp;
  I E_flow_Q_task_S_current;
  unsigned U_R( E_flow_S_signal, exit ) :1;
    #ifdef C_line_report
  W E_flow_Z_line_report_N_n_S[ J_n_10_max_digits( sizeof(N) ) + 1 ];
    #endif
  HANDLE E_flow_S_stderr;
  HANDLE E_flow_S_resume;
} *E_base_S;
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
extern char **environ;
//==============================================================================
_internal
N
E_mem_M_blk( SYSTEM_INFO *si
){  N initial_size = E_simple_Z_n_I_align_up_to_v2( sizeof( *E_base_S ) + sizeof( struct E_mem_Q_blk_Z_mapped ) + sizeof( struct E_mem_Q_blk_Z_free ) + 4 * sizeof( struct E_mem_Q_blk_Z_allocated ), si->dwAllocationGranularity );
    if( !( E_base_S = VirtualAlloc( 0
    , initial_size
    , MEM_COMMIT
    , PAGE_READWRITE
    )))
        return ~0;
        #ifdef E_mem_Q_blk_C_debug
    E_mem_Q_blk_P_fill_c( E_base_S, initial_size, 0xa5 ); //TODO Procedura usuwająca zerowanie nowej pamięci na czas usuwania zmiennych globalnych i testów.
        #endif
    E_base_S->E_flow_S_system_name = L"oux";
    E_base_S->E_flow_S_exe_name = E_mem_Q_file_S_filename_separator_w;
    E_base_S->E_mem_S_page_size = si->dwPageSize;
    E_base_S->E_mem_S_page_granulation = si->dwAllocationGranularity;
    E_base_S->E_flow_Q_timer_S_next_real_time = ~0ULL;
    U_L( E_base_S->E_flow_S_signal, exit );
    E_base_S->E_flow_S_exe_pid = GetCurrentProcessId();
    E_base_S->E_mem_Q_blk_S_decommited_id = 0;
    E_base_S->E_mem_Q_blk_S_mapped_id = 2;
    E_base_S->E_mem_Q_blk_S_free_id = 3;
    E_base_S->E_mem_Q_blk_S_allocated_id = 4;
    E_base_S->E_mem_Q_blk_S_allocated = (P)( (Pc)E_base_S + sizeof( *E_base_S ) + sizeof( struct E_mem_Q_blk_Z_mapped ) + sizeof( struct E_mem_Q_blk_Z_free ));
    E_base_S->E_mem_Q_blk_S_allocated[ E_base_S->E_mem_Q_blk_S_decommited_id ].p = (P)1;
    E_base_S->E_mem_Q_blk_S_allocated[ E_base_S->E_mem_Q_blk_S_decommited_id ].u = sizeof( struct E_mem_Q_blk_Z_decommited );
    E_base_S->E_mem_Q_blk_S_allocated[ E_base_S->E_mem_Q_blk_S_decommited_id ].n = 0;
    E_base_S->E_mem_Q_blk_S_allocated[1].p = (P)E_base_S;
    E_base_S->E_mem_Q_blk_S_allocated[1].u = 1;
    E_base_S->E_mem_Q_blk_S_allocated[1].n = sizeof( *E_base_S );
    E_base_S->E_mem_Q_blk_S_allocated[ E_base_S->E_mem_Q_blk_S_mapped_id ].p = (P)( (Pc)E_base_S + sizeof( *E_base_S ));
    E_base_S->E_mem_Q_blk_S_allocated[ E_base_S->E_mem_Q_blk_S_mapped_id ].u = sizeof( struct E_mem_Q_blk_Z_mapped );
    E_base_S->E_mem_Q_blk_S_allocated[ E_base_S->E_mem_Q_blk_S_mapped_id ].n = 1;
    E_base_S->E_mem_Q_blk_S_allocated[ E_base_S->E_mem_Q_blk_S_free_id ].p = (P)( (Pc)E_base_S + sizeof( *E_base_S ) + sizeof( struct E_mem_Q_blk_Z_mapped ));
    E_base_S->E_mem_Q_blk_S_allocated[ E_base_S->E_mem_Q_blk_S_free_id ].u = sizeof( struct E_mem_Q_blk_Z_free );
    E_base_S->E_mem_Q_blk_S_allocated[ E_base_S->E_mem_Q_blk_S_free_id ].n = 1;
    E_base_S->E_mem_Q_blk_S_allocated[ E_base_S->E_mem_Q_blk_S_allocated_id ].p = (P)E_base_S->E_mem_Q_blk_S_allocated;
    E_base_S->E_mem_Q_blk_S_allocated[ E_base_S->E_mem_Q_blk_S_allocated_id ].u = sizeof( struct E_mem_Q_blk_Z_allocated );
    E_base_S->E_mem_Q_blk_S_allocated[ E_base_S->E_mem_Q_blk_S_allocated_id ].n = 5;
    struct E_mem_Q_blk_Z_mapped *mapped_p = (P)E_base_S->E_mem_Q_blk_S_allocated[ E_base_S->E_mem_Q_blk_S_mapped_id ].p;
    mapped_p[0].p = (P)E_base_S;
    mapped_p[0].l = initial_size;
    struct E_mem_Q_blk_Z_free *free_p = (P)E_base_S->E_mem_Q_blk_S_allocated[ E_base_S->E_mem_Q_blk_S_free_id ].p;
    free_p[0].p = (P)( (Pc)E_base_S->E_mem_Q_blk_S_allocated + E_base_S->E_mem_Q_blk_S_allocated[ E_base_S->E_mem_Q_blk_S_allocated_id ].n * E_base_S->E_mem_Q_blk_S_allocated[ E_base_S->E_mem_Q_blk_S_allocated_id ].u );
    free_p[0].l = mapped_p[0].p + mapped_p[0].l - free_p[0].p;
    if( !free_p[0].l )
        free_p[0].p = 0;
    if( !( E_base_S->E_mem_Q_blk_S_threads_sync_mutex = CreateMutex( 0, no, 0 )))
        return ~1;
    return 0;
}
_internal
N
E_mem_M_file( void
){  E_base_S->E_mem_Q_file_S = E_mem_Q_tab_M( sizeof( struct E_mem_Q_file_Z ), 0 );
    if( !E_base_S->E_mem_Q_file_S )
        return ~0;
    E_base_S->E_mem_Q_file_S_buffer_l = E_base_S->E_mem_S_page_size; //CONF Wartość optymalna, ale może być wymagana większa.
    V( E_base_S->E_mem_Q_file_S_buffer = VirtualAlloc( 0, E_base_S->E_mem_Q_file_S_buffer_l, MEM_COMMIT, PAGE_READWRITE ))
        return ~1;
        #ifdef E_mem_Q_blk_C_debug
    E_mem_Q_blk_P_fill_c( E_base_S->E_mem_Q_file_S_buffer, E_base_S->E_mem_Q_file_S_buffer_l, 0xa5 ); //TODO Procedura usuwająca zerowanie nowej pamięci na czas usuwania zmiennych globalnych i testów.
        #endif
    return 0;
}
_internal
N
E_io_M_stream( void
){  E_base_S->E_io_Q_stream_out_S = E_mem_Q_tab_M( sizeof( struct E_io_Q_stream_out_Z ), 0 );
    if( !E_base_S->E_io_Q_stream_out_S )
        return ~0;
    if( E_mem_Q_tab_Q_iter_M( E_base_S->E_io_Q_stream_out_S, ~0 ) < 0 )
        return ~1;
        #ifdef C_line_report
    if( E_io_Q_stream_out_M_h( E_base_S->E_flow_S_stderr ) < 0 )
        return ~1;
        #endif
    return 0;
}
_export
N
E_base_M( HINSTANCE h_instance
){  SYSTEM_INFO si;
    GetSystemInfo( &si );
    N r = E_mem_M_blk( &si );
    if(r)
        return r;
    E_base_S->E_flow_S_exe_pid = GetCurrentProcessId();
        #ifdef C_line_report
    AllocConsole();
    if(( E_base_S->E_flow_S_stderr = CreateFile( L"CONOUT$", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE, 0, OPEN_EXISTING, 0, 0 )) == INVALID_HANDLE_VALUE )
        #else
    E_base_S->E_flow_S_stderr = GetStdHandle( STD_ERROR_HANDLE );
        #endif
        return ~0;
    E_base_S->E_flow_S_stderr_cp = GetConsoleCP();
    if( !E_base_S->E_flow_S_stderr_cp )
        return ~0;
    E_base_S->E_flow_S_h_instance = h_instance;
    E_base_S->E_flow_S_cmd_line = GetCommandLine();
    // Odblokowanie dostępu do tablicy ‹zadań›.
    E_base_S->E_flow_Q_task_S = E_mem_Q_tab_M( sizeof( struct E_flow_Q_task_Z ), 1 );
    if( !E_base_S->E_flow_Q_task_S )
        return ~0;
    struct E_flow_Q_task_Z *task = E_mem_Q_tab_R( E_base_S->E_flow_Q_task_S, 0 );
    *task = ( struct E_flow_Q_task_Z )
    { .run_state = E_flow_Z_run_state_S_ready
        #ifdef C_line_report
    , .proc_name = "main"
        #endif
    };
    task->thread = GetCurrentThread();
    U_L( task->type, system_unblock_report );
    U_L( task->type, async );
    // Ustawienie podstawowych zmiennych ‹modułu›.
    HANDLE h_module;
    V( h_module = GetModuleHandle(0) )
        return ~1;
    N l;
    Pw s = Mt( sizeof(W), 4096 );
    if( !s )
        return ~1;
    if( !( l = GetModuleFileName( h_module, s, 4096 - 1 )))
        return ~1;
    if( !E_mem_Q_blk_I_remove( &s, l + 1, 4096 - ( l + 1 )))
        return ~1;
    Pw s_ = E_text_Z_w0_R_search_last_c_( E_text_Z_w0_R_end(s), E_mem_Q_file_S_filename_separator );
    if( !E_mem_Q_blk_I_remove( &s, 0, s_ + 1 - s ))
        return ~1;
    E_base_S->E_flow_S_exe_name = s;
    V( l = GetCurrentDirectory( 0, 0 ))
        return ~1;
    s = Mt( sizeof(W), l );
    if( !s )
        return ~1;
    V( GetCurrentDirectory( l, s ) == l - 1 )
        return ~1;
    if( E_text_Z_w0_T_eq_w0( s, E_mem_Q_file_S_filename_separator_w ))
    {   r = W(s);
        if(r)
            return r;
        E_base_S->E_flow_S_cwd = E_mem_Q_file_S_filename_separator_w;
    }else
        E_base_S->E_flow_S_cwd = s;
    // Uruchomienie funkcjonalności ‹modułu›.
    E_base_S->E_flow_S_resume = CreateEvent( 0, no, no, 0 );
    if( !E_base_S->E_flow_S_resume )
        return ~1;
    E_base_S->E_flow_Q_task_S_uid_subid = E_mem_Q_tab_M( sizeof( struct E_mem_Q_tab_Z * ), 0 );
    if( !E_base_S->E_flow_Q_task_S_uid_subid )
        return ~1;
    E_base_S->E_flow_Q_report_S = E_mem_Q_tab_M( sizeof( struct E_flow_Q_report_Z ), 0 );
    if( !E_base_S->E_flow_Q_report_S )
        return ~1;
    E_base_S->E_flow_Q_timer_S = E_mem_Q_tab_M( sizeof( struct E_flow_Q_timer_Z ), 0 );
    if( !E_base_S->E_flow_Q_timer_S )
        return ~1;
    E_base_S->cpu_taken_length = si.dwNumberOfProcessors;
    E_base_S->cpu_taken = --E_base_S->cpu_taken_length ? E_mem_Q_mask_M( E_base_S->cpu_taken_length ) : 0;
    r = E_mem_M_file();
    if(r)
        return r;
    r = E_io_M_stream();
    if(r)
        return r;
    r = D_M( io, stream_write, 0 );
    if( (S)r < 0 )
        return r;
    r = D_M( mem, file_save, 0 );
    if( (S)r < 0 )
        return r;
    E_flow_Z_stat_I_stat();
    return 0;
}
/******************************************************************************/
