//-*-C-*-
/******************************************************************************/
struct E_io_Q_stream_out_Z
{ Pc data;
  N data_l;
  Pc buffer;
  N buffer_l;
  OVERLAPPED aiocb;
  HANDLE h;
  unsigned U_R( type, opened )          :1;
};
//==============================================================================
_export
I
E_io_Q_stream_out_M_h( HANDLE h
){  I id = E_mem_Q_tab_I_add( E_base_S->E_io_Q_stream_out_S );
    if( id < ~0 )
        return id;
    struct E_io_Q_stream_out_Z *stream = E_mem_Q_tab_R( E_base_S->E_io_Q_stream_out_S, id );
    U_L( stream->type, opened );
    stream->data = M( stream->data_l = 0 );
    if( !stream->data )
    {   N r = E_mem_Q_tab_I_remove( E_base_S->E_io_Q_stream_out_S, id );
        return r ? ~2 : ~0;
    }
    stream->buffer = M( stream->buffer_l = 0 );
    if( !stream->buffer )
    {   N r = E_mem_Q_tab_I_remove( E_base_S->E_io_Q_stream_out_S, id );
        return r ? ~2 : ~0;
    }
    return id;
}
_export
N
E_io_Q_stream_out_W_( I id
){  struct E_io_Q_stream_out_Z *stream = E_mem_Q_tab_R( E_base_S->E_io_Q_stream_out_S, id );
    V( CancelIo( stream->h ))
        return ~0;
    N r = W( stream->data );
    if(r)
        return ~2;
    if( U_R( stream->type, opened ))
    {   V( CloseHandle( stream->h ))
            return ~2;
    }
    r = W( stream->buffer );
    if(r)
        return ~2;
    return E_mem_Q_tab_I_remove( E_base_S->E_io_Q_stream_out_S, id );
}
//------------------------------------------------------------------------------
//NDFN w przyszłości oprócz statycznych tekstów “s” (jak jest poniżej) będą dla przenoszenia danych wycinane obszary pamięci z “E_mem_Q_blk” i przenoszone funkcją “move” (“stronami” pamięci).
_export
N
E_io_Q_stream_out_P( I id
, Pc s
, N l
){  struct E_io_Q_stream_out_Z *stream = E_mem_Q_tab_R( E_base_S->E_io_Q_stream_out_S, id );
    P p_ = E_mem_Q_blk_I_append( &stream->data, l );
    if( !p_ )
        return ~0;
    E_mem_Q_blk_I_copy( p_, s, l );
    stream->data_l += l;
    if( HasOverlappedIoCompleted( &stream->aiocb ))
    {   X_A( io, stream_write );
        X_F( io, stream_write );
    }
    return 0;
}
//------------------------------------------------------------------------------
void
E_io_out_I_completion( N32 error
, N32 l
, OVERLAPPED *aiocb
){  if(error)
        U_F( E_base_S->E_flow_S_signal, exit );
    for_each( id, E_base_S->E_io_Q_stream_out_S, E_mem_Q_tab )
    {   struct E_io_Q_stream_out_Z *stream = E_mem_Q_tab_R( E_base_S->E_io_Q_stream_out_S, id );
        if( stream->data_l )
        {   X_A( io, stream_write );
            X_F( io, stream_write );
            break;
        }
    }
}
D( io, stream_write )
{   X_M( io, stream_write );
    if( _X_var( io, stream_write ) < 0 )
    {   U_F( E_base_S->E_flow_S_signal, exit );
        goto Block;
    }
Block:
    O{  X_B( io, stream_write, 0 )
            break;
        I iter = E_mem_Q_tab_Q_iter_M( E_base_S->E_io_Q_stream_out_S, ~0 );
        if( iter < 0 )
            U_F( E_base_S->E_flow_S_signal, exit );
        else
        {   for_each_q( id, E_base_S->E_io_Q_stream_out_S, iter, E_mem_Q_tab )
            {   struct E_io_Q_stream_out_Z *stream = E_mem_Q_tab_R( E_base_S->E_io_Q_stream_out_S, id );
                N32 l;
                B r = GetOverlappedResult( stream->h, &stream->aiocb, &l, no );
                if( !r )
                {   if( GetLastError() == ERROR_IO_INCOMPLETE )
                        continue;
                    U_F( E_base_S->E_flow_S_signal, exit );
                }
                if( l != stream->buffer_l )
                {   U_F( E_base_S->E_flow_S_signal, exit );
                }
                if( !stream->data_l )
                    continue;
                if( !E_mem_Q_blk_I_remove( &stream->buffer, 0, l ))
                {   U_F( E_base_S->E_flow_S_signal, exit );
                }
                J_swap( P, stream->buffer, stream->data );
                stream->buffer_l = stream->data_l;
                stream->data_l = 0;
                _0_( &stream->aiocb );
                V( WriteFileEx( stream->h, stream->buffer, stream->buffer_l, &stream->aiocb, E_io_out_I_completion ))
                {   U_F( E_base_S->E_flow_S_signal, exit );
                }
            }
        }
    }
    X_W( io, stream_write );
}
/******************************************************************************/
