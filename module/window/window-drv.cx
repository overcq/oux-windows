//-*-C-*-
//******************************************************************************
D( window, loop )
{   X_M( window, loop );
    I_D
    {   X_B( window, loop, 0 )
            break;
        MSG msg;
        N ret;
        E_flow_Q_task_I_touch_stack();
        while( PeekMessage( &msg, 0, 0, 0, PM_REMOVE ))
        {   G_(); Gh( msg.message );
            switch(msg.message)
            { case WM_QUIT:
                    U_F( E_base_S->E_flow_S_signal, exit );
                    break;
              default:
                    TranslateMessage( &msg );
                    DispatchMessage( &msg );
                    break;
            }
        }
Cont:;
    }
    X_W( window, loop );
}
CALLBACK LRESULT
E_window_Q_window_I_proc( HWND h_window
, UINT msg
, WPARAM w_param
, LPARAM l_param
){  for_each( window_id, E_window_Q_window_S, E_mem_Q_tab )
    {   struct E_window_Q_window_Z *window = E_mem_Q_tab_R( E_window_Q_window_S, window_id );
        if( window->handle == h_window )
        {   switch(msg)
            { case WM_DESTROY:
                {   PostQuitMessage(0);
                    break;
                }
              case WM_PAINT:
                {   G_(); Gs0_( "paint" );
                    E_window_S->draw_color = E_window_Q_theme.window_bg;
                    E_window_Q_window_I_fill_Z_rectangles( window, 1, &( struct E_window_Z_rectangle ){ 0, 0, window->width, window->height } );
                    for_n( i, window->width * window->height )
                        window->object_mask[i] = ~0;
                    for_each( object_id, window->object, E_mem_Q_tab ) //NDFN Zak³adana kolejnoœæ od na spodzie do na wierzchu. Nie wiadomo, czy “_q” jest konieczne.
                    {   E_window_S->current_object = object_id;
                        struct E_window_Q_object_Z *object = E_mem_Q_tab_R( window->object, object_id );
                        if( U_R( object->mode, drag_src ))
                            E_window_S->draw_color = E_window_Q_theme.current_brace;
                        object->draw( window, object ); //NDFN Nieprzerysowywanie wszystkich obiektów dla ka¿dej klatki animacji.
                    }
                    PAINTSTRUCT ps;
                    HDC dc = BeginPaint( window->handle, &ps );
                    if( !BitBlt( dc, 0, 0, window->width, window->height, window->dc, 0, 0, SRCCOPY ))
                    {   GV_(NA); _V();
                    }
                    EndPaint( window->handle, &ps );
                    break;
                }
              case WM_SIZE:
                    if( window->width != LOWORD( l_param )
                    || window->height != HIWORD( l_param )
                    )
                    {   G_(); Gs0_( "size" );
                        window->width = LOWORD( l_param );
                        window->height = HIWORD( l_param );
                        DeleteObject( window->drawable );
                        DeleteDC( window->dc );
                        HDC dc = GetDC( window->handle );
                        window->dc = CreateCompatibleDC(dc);
                        if( !window->dc )
                        {   GV_(NA); _V();
                        }
                        window->drawable = CreateCompatibleBitmap( dc, window->width, window->height );
                        if( !window->drawable )
                        {   GV_(NA); _V();
                        }
                        ReleaseDC( window->handle, dc );
                        SelectObject( window->dc, window->drawable );
                        if( !E_mem_Q_blk_M_replace( &window->object_mask, window->width * window->height * sizeof( *window->object_mask )))
                        {   GV_(NA); _V();
                        }
                        E_window_Q_object_I_lay(window);
                        RedrawWindow( window->handle, 0, 0, RDW_INVALIDATE );
                    }
                    break;
              default:
                {   G_(); Gh(msg);
                    return DefWindowProc( h_window, msg, w_param, l_param );
                }
            }
            return 0;
        }
    }
    G_(); Gh( h_window ); Gh(msg);
    return DefWindowProc( h_window, msg, w_param, l_param );
}
//******************************************************************************
