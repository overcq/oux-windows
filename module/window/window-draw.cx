//-*-C-*-
//******************************************************************************
enum E_window_Z_aa_pixel
{ E_window_Z_aa_pixel_S_e = 1 << 0,
  E_window_Z_aa_pixel_S_se = 1 << 1,
  E_window_Z_aa_pixel_S_s = 1 << 2,
  E_window_Z_aa_pixel_S_sw = 1 << 3,
  E_window_Z_aa_pixel_S_w = 1 << 4,
  E_window_Z_aa_pixel_S_nw = 1 << 5,
  E_window_Z_aa_pixel_S_n = 1 << 6,
  E_window_Z_aa_pixel_S_ne = 1 << 7
};
struct E_window_Z_arc
{ int left, top, right, bottom;
  int angle_start_x, angle_start_y, angle_end_x, angle_end_y;
};
//==============================================================================
COLORREF
E_window_Z_color_M_gray( N8 luminance
){  return RGB( luminance, luminance, luminance );
}
COLORREF
E_window_Z_color_P_luminance( COLORREF color
, F luminance
){  J_assert( luminance >= 0 && luminance <= 1 );
    N8 red = GetRValue(color);
    N8 green = GetGValue(color);
    N8 blue = GetBValue(color);
    F color_luminance = E_window_Z_color_R_luminance( color );
    if( luminance < color_luminance )
    {   red = lround( red * luminance / color_luminance );
        green = lround( green * luminance / color_luminance );
        blue = lround( blue * luminance / color_luminance );
    }else if( luminance > color_luminance )
    {   red += lround(( 0xff - red ) * ( luminance - color_luminance ) / ( 1 - color_luminance ));
        green += lround(( 0xff - green ) * ( luminance - color_luminance ) / ( 1 - color_luminance ));
        blue += lround(( 0xff - blue ) * ( luminance - color_luminance ) / ( 1 - color_luminance ));
    }else
        return color;
    return RGB( red, green, blue );
}
F
E_window_Z_color_R_luminance( COLORREF color
){  return 0;//( display->red_luminance_ratio * GetRValue(color) + display->green_luminance_ratio * GetGValue(color) + display->blue_luminance_ratio * GetBValue(color) ) / 255;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
E_window_Q_window_I_draw_P_color( COLORREF color
){  E_window_S->draw_color = color;
}
B
E_window_Q_window_I_draw_P_pen( struct E_window_Q_window_Z *window
, COLORREF color
){  HPEN pen = CreatePen( PS_SOLID, 0, color );
    V(pen)
        return false;
    HPEN old_pen = SelectObject( window->dc, pen );
    V( old_pen )
    {   V_( DeleteObject(pen));
        return false;
    }
    V_( DeleteObject( old_pen ));
    return true;
}
B
E_window_Q_window_I_draw_P_brush( struct E_window_Q_window_Z *window
, COLORREF color
){  HBRUSH brush = CreateSolidBrush(color);
    V(brush)
        return false;
    HPEN old_brush = SelectObject( window->dc, brush );
    V( old_brush )
    {   V_( DeleteObject(brush));
        return false;
    }
    V_( DeleteObject( old_brush ));
    return true;
}
B
E_window_Q_object_mask_I_draw_P_pen( struct E_window_Q_window_Z *window
, I object_id
){  HPEN pen = CreatePen( PS_SOLID, 0, object_id );
    V(pen)
        return false;
    HPEN old_pen = SelectObject( window->dc_object_mask, pen );
    V( old_pen )
    {   V_( DeleteObject(pen));
        return false;
    }
    V_( DeleteObject( old_pen ));
    return true;
}
B
E_window_Q_object_mask_I_draw_P_brush( struct E_window_Q_window_Z *window
, I object_id
){  HBRUSH brush = CreateSolidBrush( object_id );
    V(brush)
        return false;
    HPEN old_brush = SelectObject( window->dc_object_mask, brush );
    V( old_brush )
    {   V_( DeleteObject(brush));
        return false;
    }
    V_( DeleteObject( old_brush ));
    return true;
}
//------------------------------------------------------------------------------
B
E_window_Q_window_I_draw_Z_points(
  struct E_window_Q_window_Z *window
, N n
, POINT *points
){  J_assert(n);
    for_n( i, n )
        if( points[i].x < window->width && points[i].y < window->height )
        {   if( U_R( E_window_S->state, draw_object_drag_move ))
            {   HRGN res = CreateRectRgn( 0, 0, 0, 0 );
                V(res)
                    return false;
                HRGN combine = CreateRectRgn( points[i].x, points[i].y, points[i].x + 1, points[i].y + 1 );
                V(combine)
                {   V_( DeleteObject(res));
                    return false;
                }
                V( CombineRgn( res, E_window_S->region, combine, RGN_OR ) != ERROR )
                {   V_( DeleteObject(combine));
                    V_( DeleteObject(res));
                    return false;
                }
                V_( DeleteObject( E_window_S->region ));
                V_( DeleteObject(combine));
                E_window_S->region = res;
            }
            V( SetPixelV( window->dc, points[i].x, points[i].y, E_window_S->draw_color ))
                return false;
            if( !U_R( E_window_S->state, draw_object_drag_move ))
            {   V( SetPixelV( window->dc_object_mask, points[i].x, points[i].y, E_window_S->current_object ))
                    return false;
            }
        }
    return true;
}
B
E_window_Q_window_I_draw_aa_Z_points(
  struct E_window_Q_window_Z *window
, N n
, POINT *points
, F brightness
){  J_assert(n);
    J_assert( brightness >= 0 && brightness <= 1 );
    COLORREF *Mt_( colors, n );
    if( !colors )
        return false;
    for_n( i, n )
    {   N p[8];
        p[0] = points[i].x + 1 < window->width ? E_window_Q_image_R_pixel( window, points[i].x + 1, points[i].y ) : E_window_S->draw_color;
        p[1] = points[i].x + 1 < window->width && points[i].y + 1 < window->height ? E_window_Q_image_R_pixel( window, points[i].x + 1, points[i].y + 1 ) : E_window_S->draw_color;
        p[2] = points[i].y + 1 < window->height ? E_window_Q_image_R_pixel( window, points[i].x, points[i].y + 1 ) : E_window_S->draw_color;
        p[3] = points[i].x > 0 && points[i].y + 1 < window->height ? E_window_Q_image_R_pixel( window, points[i].x - 1, points[i].y + 1 ) : E_window_S->draw_color;
        p[4] = points[i].x > 0 ? E_window_Q_image_R_pixel( window, points[i].x - 1, points[i].y ) : E_window_S->draw_color;
        p[5] = points[i].x > 0 && points[i].y > 0 ? E_window_Q_image_R_pixel( window, points[i].x - 1, points[i].y - 1 ) : E_window_S->draw_color;
        p[6] = points[i].y > 0 ? E_window_Q_image_R_pixel( window, points[i].x, points[i].y - 1 ) : E_window_S->draw_color;
        p[7] = points[i].x + 1 < window->width && points[i].y > 0 ? E_window_Q_image_R_pixel( window, points[i].x + 1, points[i].y - 1 ) : E_window_S->draw_color;
        N n_ = 0;
        N background_red = 0, background_green = 0, background_blue = 0;
        for_n( j, 8 )
            if( p[j] != E_window_S->draw_color )
            {   background_red += GetRValue( p[j] );
                background_green += GetGValue( p[j] );
                background_blue += GetBValue( p[j] );
                n_++;
            }
        if( n_ )
        {   background_red /= n_;
            background_green /= n_;
            background_blue /= n_;
        }else
        {   background_red = GetRValue( E_window_Q_theme.window_bg );
            background_green = GetGValue( E_window_Q_theme.window_bg );
            background_blue = GetBValue( E_window_Q_theme.window_bg );
        }
        N red = GetRValue( E_window_S->draw_color );
        N green = GetGValue( E_window_S->draw_color );
        N blue = GetBValue( E_window_S->draw_color );
        if( red > background_red )
            red = background_red + ( red - background_red ) * brightness;
        else
            red = background_red - ( background_red - red ) * brightness;
        if( green > background_green )
            green = background_green + ( green - background_green ) * brightness;
        else
            green = background_green - ( background_green - green ) * brightness;
        if( blue > background_blue )
            blue = background_blue + ( blue - background_blue ) * brightness;
        else
            blue = background_blue - ( background_blue - blue ) * brightness;
        colors[i] = RGB( red, green, blue );
    }
    for_n_( i, n )
    {   E_window_Q_window_I_draw_P_color( colors[i] );
        E_window_Q_window_I_draw_Z_points( window, 1, &points[i] );
    }
    W(colors);
    return true;
}
B
E_window_Q_window_I_draw_Z_lines(
  struct E_window_Q_window_Z *window
, N n
, POINT *points
, DWORD thickness
){  J_assert( n > 1 );
    J_assert( thickness > 0 );
    HPEN pen = ExtCreatePen( PS_GEOMETRIC | PS_SOLID | PS_ENDCAP_FLAT | PS_JOIN_BEVEL
    , thickness
    , &( LOGBRUSH )
      { BS_SOLID
      , E_window_S->draw_color
      }
    , 0, 0
    );
    V(pen)
        return false;
    HPEN old_pen = SelectObject( window->dc, pen );
    V( old_pen )
    {   V_( DeleteObject(pen));
        return false;
    }
    HPEN pen_object_mask, old_pen_object_mask;
    if( !U_R( E_window_S->state, draw_object_drag_move ))
    {   pen_object_mask = ExtCreatePen( PS_GEOMETRIC | PS_SOLID | PS_ENDCAP_FLAT | PS_JOIN_BEVEL
        , thickness
        , &( LOGBRUSH )
          { BS_SOLID
          , E_window_S->current_object
          }
        , 0, 0
        );
        V( pen_object_mask )
        {   if( SelectObject( window->dc, old_pen ))
            {   V_( DeleteObject(pen) );
            }else
            {   V_( DeleteObject( old_pen ));
            }
            return false;
        }
        old_pen_object_mask = SelectObject( window->dc_object_mask, pen_object_mask );
        V( old_pen_object_mask )
        {   V_( DeleteObject( pen_object_mask ));
            if( SelectObject( window->dc, old_pen ))
            {   V_( DeleteObject(pen));
            }else
            {   V_( DeleteObject( old_pen ));
            }
            return false;
        }
    }
    B r = Polyline( window->dc, points, n );
    V(r)
        goto End;
    if( !U_R( E_window_S->state, draw_object_drag_move ))
    {   r = Polyline( window->dc_object_mask, points, n );
        V(r);
    }
End:if( SelectObject( window->dc, old_pen ))
    {   V_( DeleteObject(pen) );
    }else
    {   V_( DeleteObject( old_pen ));
    }
    if( !U_R( E_window_S->state, draw_object_drag_move ))
        if( SelectObject( window->dc_object_mask, old_pen_object_mask ))
        {   V_( DeleteObject( pen_object_mask ));
        }else
        {   V_( DeleteObject( old_pen_object_mask ));
        }
    return r;
}
B
E_window_Q_window_I_draw_Z_rectangles(
  struct E_window_Q_window_Z *window
, N n
, RECT *rectangles
){  J_assert(n);
    if( U_R( E_window_S->state, draw_object_drag_move ))
    {   for_n( i, n )
        {   HRGN res = CreateRectRgn( 0, 0, 0, 0 );
            V(res)
                return false;
            HRGN combine = CreateRectRgn( rectangles[i].left, rectangles[i].top, rectangles[i].right, rectangles[i].top + 1 );
            V(combine)
            {   V_( DeleteObject(res));
                return false;
            }
            V( CombineRgn( res, E_window_S->region, combine, RGN_OR ) != ERROR )
            {   V_( DeleteObject(combine));
                V_( DeleteObject(res));
                return false;
            }
            V_( DeleteObject( E_window_S->region ));
            V_( DeleteObject(combine));
            E_window_S->region = CreateRectRgn( 0, 0, 0, 0 );
            V( E_window_S->region )
                return false;
            combine = CreateRectRgn( rectangles[i].right - 1, rectangles[i].top, rectangles[i].right, rectangles[i].bottom );
            V(combine)
            {   V_( DeleteObject(res));
                return false;
            }
            V( CombineRgn( E_window_S->region, res, combine, RGN_OR ) != ERROR )
            {   V_( DeleteObject(combine));
                V_( DeleteObject(res));
                return false;
            }
            V_( DeleteObject(res));
            V_( DeleteObject(combine));
            res = CreateRectRgn( 0, 0, 0, 0 );
            V(res)
                return false;
            combine = CreateRectRgn( rectangles[i].left, rectangles[i].bottom - 1, rectangles[i].right, rectangles[i].bottom );
            V(combine)
            {   V_( DeleteObject(res));
                return false;
            }
            V( CombineRgn( res, E_window_S->region, combine, RGN_OR ) != ERROR )
            {   V_( DeleteObject(combine));
                V_( DeleteObject(res));
                return false;
            }
            V_( DeleteObject( E_window_S->region ));
            V_( DeleteObject(combine));
            E_window_S->region = CreateRectRgn( 0, 0, 0, 0 );
            V( E_window_S->region )
                return false;
            combine = CreateRectRgn( rectangles[i].left, rectangles[i].top, rectangles[i].left + 1, rectangles[i].bottom );
            V(combine)
            {   V_( DeleteObject(res));
                return false;
            }
            V( CombineRgn( E_window_S->region, res, combine, RGN_OR ) != ERROR )
            {   V_( DeleteObject(combine));
                V_( DeleteObject(res));
                return false;
            }
            V_( DeleteObject(res));
            V_( DeleteObject(combine));
        }
    }
    HBRUSH brush = CreateSolidBrush( E_window_S->draw_color );
    V(brush)
        return false;
    HBRUSH brush_object_mask = CreateSolidBrush( E_window_S->current_object );
    V( brush_object_mask )
    {   V_( DeleteObject(brush));
        return false;
    }
    for_n( i, n )
    {   V( FrameRect( window->dc, &rectangles[i], brush ))
        {   V_( DeleteObject( brush_object_mask ));
            V_( DeleteObject(brush));
            return false;
        }
        if( !U_R( E_window_S->state, draw_object_drag_move ))
        {   V( FrameRect( window->dc_object_mask, &rectangles[i], brush_object_mask ))
            {   V_( DeleteObject( brush_object_mask ));
                V_( DeleteObject(brush));
                return false;
            }
        }
    }
    V_( DeleteObject( brush_object_mask ));
    V_( DeleteObject(brush));
    return true;
}
B
E_window_Q_window_I_draw_Z_arcs(
  struct E_window_Q_window_Z *window
, N n
, struct E_window_Z_arc *arcs
){  J_assert(n);
    if( U_R( E_window_S->state, draw_object_drag_move ))
        ; //NDFN Brak procedury rysowania 'regionu' dla "drag & drop".
    E_window_Q_object_mask_I_draw_P_pen( window, E_window_S->current_object );
    for_n( i, n )
    {   V( Arc( window->dc
        , arcs[i].left, arcs[i].top, arcs[i].right, arcs[i].bottom
        , arcs[i].angle_start_x, arcs[i].angle_start_y
        , arcs[i].angle_end_x, arcs[i].angle_end_y
        ))
            return false;
        if( !U_R( E_window_S->state, draw_object_drag_move ))
        {   V( Arc( window->dc_object_mask
            , arcs[i].left, arcs[i].top, arcs[i].right, arcs[i].bottom
            , arcs[i].angle_start_x, arcs[i].angle_start_y
            , arcs[i].angle_end_x, arcs[i].angle_end_y
            ))
                return false;
        }
    }
    return true;
}
B
E_window_Q_window_I_fill_Z_points(
  struct E_window_Q_window_Z *window
, N n
, POINT *points
){  J_assert( n > 2 );
    if( U_R( E_window_S->state, draw_object_drag_move ))
    {   //NDFN Brak procedury rysowania 'regionu' dla "drag & drop".
        HRGN res = CreateRectRgn( 0, 0, 0, 0 );
        V(res)
            return false;
        HRGN combine = CreatePolygonRgn( points, n, WINDING );
        V(combine)
        {   V_( DeleteObject(res));
            return false;
        }
        V( CombineRgn( res, E_window_S->region, combine, RGN_OR ) != ERROR )
        {   V_( DeleteObject(combine));
            V_( DeleteObject(res));
            return false;
        }
        V_( DeleteObject( E_window_S->region ));
        V_( DeleteObject(combine));
        E_window_S->region = res;
    }
    E_window_Q_object_mask_I_draw_P_pen( window, E_window_S->current_object );
    E_window_Q_object_mask_I_draw_P_brush( window, E_window_S->current_object );
    V( Polygon( window->dc, points, n ))
        return false;
    if( !U_R( E_window_S->state, draw_object_drag_move ))
    {   V( Polygon( window->dc_object_mask, points, n ))
            return false;
    }
    return true;
}
B
E_window_Q_window_I_fill_Z_rectangles(
  struct E_window_Q_window_Z *window
, N n
, RECT *rectangles
){  J_assert(n);
    if( U_R( E_window_S->state, draw_object_drag_move ))
    {   for_n( i, n )
        {   HRGN res = CreateRectRgn( 0, 0, 0, 0 );
            V(res)
                return false;
            HRGN combine = CreateRectRgnIndirect( &rectangles[i] );
            V(combine)
            {   V_( DeleteObject(res));
                return false;
            }
            V( CombineRgn( res, E_window_S->region, combine, RGN_OR ) != ERROR )
            {   V_( DeleteObject(combine));
                V_( DeleteObject(res));
                return false;
            }
            V_( DeleteObject( E_window_S->region ));
            V_( DeleteObject(combine));
            E_window_S->region = res;
        }
    }
    E_window_Q_object_mask_I_draw_P_pen( window, E_window_S->current_object );
    E_window_Q_object_mask_I_draw_P_brush( window, E_window_S->current_object );
    for_n( i, n )
    {   V( Rectangle( window->dc, rectangles[i].left, rectangles[i].top, rectangles[i].right, rectangles[i].bottom ))
            return false;
        if( !U_R( E_window_S->state, draw_object_drag_move ))
        {   V( Rectangle( window->dc_object_mask, rectangles[i].left, rectangles[i].top, rectangles[i].right, rectangles[i].bottom ))
                return false;
        }
    }
    return true;
}
B
E_window_Q_window_I_fill_Z_arcs(
  struct E_window_Q_window_Z *window
, N n
, RECT *arcs
){  J_assert(n);
    if( U_R( E_window_S->state, draw_object_drag_move ))
    {   for_n( i, n )
        {   HRGN res = CreateRectRgn( 0, 0, 0, 0 );
            V(res)
                return false;
            HRGN combine = CreateEllipticRgnIndirect( &arcs[i] );
            V(combine)
            {   V_( DeleteObject(res));
                return false;
            }
            V( CombineRgn( res, E_window_S->region, combine, RGN_OR ) != ERROR )
            {   V_( DeleteObject(combine));
                V_( DeleteObject(res));
                return false;
            }
            V_( DeleteObject( E_window_S->region ));
            V_( DeleteObject(combine));
            E_window_S->region = res;
        }
    }
    E_window_Q_object_mask_I_draw_P_pen( window, E_window_S->current_object );
    E_window_Q_object_mask_I_draw_P_brush( window, E_window_S->current_object );
    for_n( i, n )
    {   V( Ellipse( window->dc, arcs[i].left, arcs[i].top, arcs[i].right, arcs[i].bottom ))
            return false;
        if( !U_R( E_window_S->state, draw_object_drag_move ))
        {   V( Ellipse( window->dc_object_mask, arcs[i].left, arcs[i].top, arcs[i].right, arcs[i].bottom ))
                return false;
        }
    }
    return true;
}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void
E_window_Q_object_I_draw_P_color(
  struct E_window_Q_object_Z *object
, COLORREF color
){  if( !U_R( object->state, drag_src ))
        E_window_Q_window_I_draw_P_color(color);
}
//------------------------------------------------------------------------------
B
E_window_Q_object_I_draw_Z_points(
  struct E_window_Q_window_Z *window
, struct E_window_Q_object_Z *object
, N n
, POINT *points
){  for_n( i, n )
    {   points[i].x += object->x;
        points[i].y += object->y;
    }
    return E_window_Q_window_I_draw_Z_points( window, n, points );
}
B
E_window_Q_object_I_draw_aa_Z_points(
  struct E_window_Q_window_Z *window
, struct E_window_Q_object_Z *object
, N n
, POINT *points
, F brightness
){  for_n( i, n )
    {   points[i].x += object->x;
        points[i].y += object->y;
    }
    if( !~E_window_Q_window_I_draw_aa_Z_points( window
    , n
    , points
    , brightness
    ))
        return false;
    return true;
}
B
E_window_Q_object_I_draw_Z_lines(
  struct E_window_Q_window_Z *window
, struct E_window_Q_object_Z *object
, N n
, POINT *points
, DWORD thickness
){  for_n( i, n )
    {   points[i].x += object->x;
        points[i].y += object->y;
    }
    B ret = E_window_Q_window_I_draw_Z_lines( window, n, points, thickness );
    if( !ret )
        return false;
    if( U_R( E_window_S->state, draw_object_drag_move ))
    {   struct E_window_Q_window_Z *window_ = E_mem_Q_tab_R( E_window_Q_window_S, E_window_S->dnd_src_window );
        struct E_window_Q_object_Z *object_ = E_mem_Q_tab_R( window_->object, E_window_S->dnd_src_object );
        for_n( x, object_->width )
        {   for_n( y, object_->height )
                if( E_window_Q_object_mask_R_object_id( window_, object_->x + x, object_->y + y ) == E_window_S->dnd_src_object )
                {   HRGN res = CreateRectRgn( 0, 0, 0, 0 );
                    V(res)
                        return false;
                    HRGN combine = CreateRectRgn( object->x + x, object->y + y, object->x + x + 1, object->y + y + 1 );
                    V(combine)
                    {   V_( DeleteObject(res));
                        return false;
                    }
                    V( CombineRgn( res, E_window_S->region, combine, RGN_OR ) != ERROR )
                    {   V_( DeleteObject(combine));
                        V_( DeleteObject(res));
                        return false;
                    }
                    V_( DeleteObject( E_window_S->region ));
                    V_( DeleteObject(combine));
                    E_window_S->region = res;
                }
        }
    }
    return true;
}
B
E_window_Q_object_I_draw_Z_rectangles(
  struct E_window_Q_window_Z *window
, struct E_window_Q_object_Z *object
, N n
, RECT *rectangles
){  for_n( i, n )
    {   rectangles[i].left += object->x;
        rectangles[i].top += object->y;
        rectangles[i].right += object->x;
        rectangles[i].bottom += object->y;
    }
    return E_window_Q_window_I_draw_Z_rectangles( window, n, rectangles );
}
B
E_window_Q_object_I_draw_Z_arcs(
  struct E_window_Q_window_Z *window
, struct E_window_Q_object_Z *object
, N n
, struct E_window_Z_arc *arcs
){  for_n( i, n )
    {   arcs[i].left += object->x;
        arcs[i].top += object->y;
        arcs[i].right += object->x;
        arcs[i].bottom += object->y;
    }
    return E_window_Q_window_I_draw_Z_arcs( window, n, arcs );
}
B
E_window_Q_object_I_fill_Z_points(
  struct E_window_Q_window_Z *window
, struct E_window_Q_object_Z *object
, N n
, POINT *points
){  for_n( i, n )
    {   points[i].x += object->x;
        points[i].y += object->y;
    }
    return E_window_Q_window_I_fill_Z_points( window, n, points );
}
B
E_window_Q_object_I_fill_Z_rectangles(
  struct E_window_Q_window_Z *window
, struct E_window_Q_object_Z *object
, N n
, RECT *rectangles
){  for_n( i, n )
    {   rectangles[i].left += object->x;
        rectangles[i].top += object->y;
        rectangles[i].right += object->x;
        rectangles[i].bottom += object->y;
    }
    return E_window_Q_window_I_fill_Z_rectangles( window, n, rectangles );
}
B
E_window_Q_object_I_fill_Z_arcs(
  struct E_window_Q_window_Z *window
, struct E_window_Q_object_Z *object
, N n
, RECT *arcs
){  for_n( i, n )
    {   arcs[i].left += object->x;
        arcs[i].top += object->y;
        arcs[i].right += object->x;
        arcs[i].bottom += object->y;
    }
    return E_window_Q_window_I_fill_Z_arcs( window, n, arcs );
}
//******************************************************************************
